package nl.thijsmolendijk.ollycode.runtime;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map.Entry;

/**
 * Interpreter directly evaluates the abstract syntax tree generated by the
 * Parser. It checks the semantics as it process the tree.
 *
 * @author molenzwiebel
 */
public class Interpreter {
	private OCRuntime runtime;
	/**
     * Map of variables to their objects
     */
    private HashMap<String, OCObject> symbolTable = new HashMap<>();
    /**
     * List of all functions defined
     */
    private List<OCFunction> functions = new ArrayList<>();
    
    public Interpreter(OCRuntime rt) {
    	this.runtime = rt;
    }
    
    /**
     * @return the runtime for this interpreter
     */
    public OCRuntime getRuntime() {
    	return runtime;
    }
    
    /**
     * Get the current value of a variable.
     * @param name variable name
     * @return the value of the variable
     */
    public OCObject getVariable(String name) {
        if (!symbolTable.containsKey(name)) {
            throw new NullPointerException(name);
        }
        return symbolTable.getOrDefault(name, OCNull.INSTANCE);
    }
    
    /**
     * Sets the value of a variable
     * @param name variable name
     * @param value new value for the variable
     */
    public void setVariable(String name, OCObject value) {
        symbolTable.put(name, value);
    }
    
    /**
     * Gets the function with the specified name and argument count
     * @param name the function name
     * @param argCount the amount of arguments the function needs to have
     * @return the function
     */
    public OCObject getFunction(String name, int argCount) {
        return functions.stream().filter(x -> x.getName().equals(name) && x.getParameterCount() == argCount).map(x -> (OCObject) x).findAny().orElse(OCNull.INSTANCE);
    }
    
    /**
     * Adds a function
     * @param func the function
     */
    public void addFunction(OCFunction func) {
        functions.add(func);
    }
    
    /**
     * @return a list of all defined variables
     */
    public List<String> getDefinedVariables() {
    	return new ArrayList<>(symbolTable.keySet());
    }
    
	/**
	 * Invokes a function on this object
	 * @param name the name of the function
	 * @param arguments the arguments
	 * @return the result of the function evaluation
	 */
	public OCObject invokeFunction(String name, List<OCObject> arguments) {
		List<String> instanceVariables = getDefinedVariables();
		OCObject obj = getFunction(name, arguments.size());
		if (obj == OCNull.INSTANCE) throw new RuntimeException("Tried to invoke "+name+" on "+this.toString()+", but function "+name+" was not defined");
		
		OCFunction func = (OCFunction) obj;
		for (int i = 0; i < arguments.size(); i++) {
			if (instanceVariables.contains(func.getParameterName(i))) throw new RuntimeException("Parameter name is the same as one of the instance variables.");
			setVariable(func.getParameterName(i), arguments.get(i));
		}
		
		OCObject returnValue = func.eval(this);
		removeNonMatching(instanceVariables);
		return returnValue;
	}
    
    /**
     * Removes all the variables that are not in the provided list. Used for clearing variables after invoking a function
     * @param filter
     */
    public void removeNonMatching(List<String> filter) {
    	Iterator<Entry<String, OCObject>> it = symbolTable.entrySet().iterator();
    	while (it.hasNext()) {
    		Entry<String, OCObject> entry = it.next();
    		if (!filter.contains(entry.getKey())) it.remove();
    	}
    }
}
